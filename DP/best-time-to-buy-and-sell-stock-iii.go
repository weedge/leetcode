package main

// twice
// ä¸€å¤©ä¸€å…±å°±æœ‰äº”ä¸ªçŠ¶æ€:
//	0.æ²¡æœ‰æ“ä½œ
//	1.ç¬¬ä¸€æ¬¡ä¹°å…¥
//	2.ç¬¬ä¸€æ¬¡å–å‡º
//	3.ç¬¬äºŒæ¬¡ä¹°å…¥
//	4.ç¬¬äºŒæ¬¡å–å‡º
// DP[i][j]ä¸­ iè¡¨ç¤ºç¬¬iå¤©ï¼Œjä¸º [0 - 4] äº”ä¸ªçŠ¶æ€ï¼ŒDP[i][j]è¡¨ç¤ºç¬¬iå¤©çŠ¶æ€jæ‰€å‰©æœ€å¤§çŽ°é‡‘ã€‚
// ç¬¬iå¤©æ²¡æœ‰æ“ä½œ DP[i][0] = DP[i-1][0]
// ç¬¬iå¤©ç¬¬ä¸€æ¬¡ä¹°å…¥æ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[i][1] = max(DP[i-1][0] - prices[i], DP[i-1][1]);
// ç¬¬iå¤©ç¬¬ä¸€æ¬¡å–å‡ºæ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[i][2] = max(DP[i-1][1] + prices[i], DP[i-1][2]);
// ç¬¬iå¤©ç¬¬äºŒæ¬¡ä¹°å…¥æ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[i][3] = max(DP[i-1][2] - prices[i], DP[i-1][3]);
// ç¬¬iå¤©ç¬¬äºŒæ¬¡å–å‡ºæ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[i][4] = max(DP[i-1][3] + prices[i], DP[i-1][4]);
// åˆå§‹ï¼š
// ç¬¬0å¤©æ²¡æœ‰æ“ä½œ DP[0][0] = 0 // ç©·å…‰ðŸ¥šï¼Œåˆå§‹æ²¡é’±ä½œä¸ºå¯åŠ¨èµ„é‡‘
// ç¬¬0å¤©ç¬¬ä¸€æ¬¡ä¹°å…¥æ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[0][1] = -prices[0]
// ç¬¬0å¤©ç¬¬ä¸€æ¬¡å–å‡ºæ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[0][2] = 0
// ç¬¬0å¤©ç¬¬äºŒæ¬¡ä¹°å…¥æ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[0][3] = -prices[0]
// ç¬¬0å¤©ç¬¬äºŒæ¬¡å–å‡ºæ‰€å‰©æœ€å¤§çŽ°é‡‘ DP[0][4] = 0
func maxProfitIII(prices []int) int {
	if len(prices) == 0 {
		return 0
	}
	Max := func(a, b int) int {
		if a > b {
			return a
		}
		return b
	}
	max := 0
	n := len(prices)
	dp := make([][]int, n)
	dp[0] = make([]int, 5)
	dp[0][0], dp[0][2], dp[0][4] = 0, 0, 0
	dp[0][1], dp[0][3] = -prices[0], -prices[0]
	for i := 1; i < n; i++ {
		dp[i] = make([]int, 5)
		dp[i][0] = dp[i-1][0]
		dp[i][1] = Max(dp[i-1][1], dp[i-1][0]-prices[i])
		dp[i][2] = Max(dp[i-1][2], dp[i-1][1]+prices[i])
		dp[i][3] = Max(dp[i-1][3], dp[i-1][2]-prices[i])
		dp[i][4] = Max(dp[i-1][4], dp[i-1][3]+prices[i])

		if dp[i][4] > max {
			max = dp[i][4]
		}
	}

	return max
}

func main() {
	prices := []int{3, 3, 5, 0, 0, 3, 1, 4}
	println(maxProfitIII(prices))

	return
}
